{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/07/04/hello-world/"},{"title":"力扣(LeetCode)-总结-回文","text":"回文性质 去掉两头的内部仍然是回文的，考虑动态规划 反转后半截，注意奇数个时中间数的处理，考虑一些首不可能的情况 对于忽略大小写的使用Charactor.toLowerCase() 回文子串2种基本方法12345678910111213141516171819202122232425262728// 动态规划int n = s.length();boolean[][] dp = new boolean[n][n];// 外层枚举右边界，内层枚举左边界 for(int j = 0;j &lt; n; j++){ for(int i = 0; i &lt;= j; i++){ char left = s.charAt(i); char right = s.charAt(j); boolean flag = (left == right); //dp[i][j]=(si==sj)&amp;&amp;(dp[i+1][j-1])，但有两个例外的情况，dp[i][i]单个字符为true，两个字符的若这两个字符相同直接为true，综合起来为j-i&lt;2时自动为true if(flag &amp;&amp; ((j - i) &lt; 2|| dp[i+1][j-1])){ dp[i][j] = true; // 要执行的逻辑 } } }// 中心拓展法// 寻找可能的回文中心 单个字符or相等的两个字符，不断向两侧扩展if两侧不越界且字符相等，分别对应了回文长度是奇数和偶数的情况// 这两种情况可以用一个方法处理，因为单个字符的相当于自己和自己比较后相等，要枚举判断所有的回文中心(包括单个的和相邻两个字符的)n个字符可以形成n+n-1=2n-1个，不论是奇数中心还是偶数中心，都用边界表示int l = i / 2, r = i / 2 + i % 2 int n = s.length(), ans = 0; for (int i = 0; i &lt; 2 * n - 1; ++i) { int l = i / 2, r = i / 2 + i % 2; while (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r)) { --l; ++r; // 执行逻辑 } } n=4时生成7个中心，每个中心按0~2n-2编号，得到左边界、有边界和i编号的关系，起始是i/2，右边界+0或者+1，相当于+i%2 练习lico_234 回文链表描述：判断是否位回文链表 快慢指针找中点+反转链表 初始slow=fast=head,当fast==nullorfast.next==null时停止，奇数个时fast停在最中间(考虑回文奇数个中间的不用判断，需要slow往下再走一个)，偶数个时slow是分界线右边的 fast归到头结点，断掉后半部分反转链表，一一比对 反转后边链表相当于head是当前的slow，prev=null，反转链表后新节点的头结点是prev， 回文子串lico_5 最长回文子字符串方法一：动态规划 动态转移：去掉两头的内部仍然是回文的。P(i,j)=P(i+1,j-1)&amp;&amp;(Si==Sj) 边界：只有一个字符 P(i,i)=true,两个字符的子串，这两个字符相等才是true，这两种情况可以汇总为字符长度小于等于2，采用枚举左右边界做内外层循环时 123456if(flag &amp;&amp; ((j - i) &lt; 2|| dp[i+1][j-1])){ dp[i][j] = true; // 要执行的逻辑 maxlen = j - i + 1; //最长字符串的长度 begin = left; //最长字符串的起始 } 结果：满足P(i,j)=true的最大i-j+1，最后用str.substring(begin,begin+maxlen)得到返回 动规顺序，右边界在外层，左边界枚举在内层。 实际上可以改为&lt;3因为中间哪个字符必然是回文的，整个字符串属于aba类型 方法二：中心扩展 从边界情况逐渐向更长子串扩展，**单个字符做回文中心(奇数长度的回文子串)，两个字符且两个字符相等的做回文中心(最后扩展出偶数长度的回文子串)**，如果两边的字符相等就继续扩展，直到两侧到达边界或不相等 12345678910111213141516171819202122232425if (s == null || s.length() &lt; 1) { return &quot;&quot;; }//一开始左右边界都是0 int start = 0, end = 0;//每个字符都可以做单个回文中心，可以作双字符回文中心的左边界，在方法里判断是否越界 for (int i = 0; i &lt; s.length(); i++) { int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) { start = i - (len - 1) / 2; end = i + len / 2; } } return s.substring(start, end + 1); } public int expandAroundCenter(String s, int left, int right) { while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) { --left; ++right; } return right - left - 1; } lico_409 取字母组装最长回文字符串 用字典数组存储char-count,出现的次数 每种字符使用count/2*2次(如果是5个使用2对，4个) 如果最后count&lt;size说明至少有一个是奇数，则最后结果+1把他放中间 123456789int[] letters = new int[128]; char[] arr = s.toCharArray(); for(char c : arr) letters[c]++; int res = 0; for(int i : letters) res += i - (i % 2); return res == arr.length ? res : res + 1; lico_9 判断整数是否是回文数方法一：计算出所有位看首位是否相等，可以边取两边边判断如有不等立刻返回false 首先先找到最大的1000… 对比首尾 首：x/div 尾：x%10 更新x和div x：`x=(x%div)/10 去掉首尾 %div去掉首，/10去掉尾 div：每次div/100,因为是少了两位 12345678910111213//边界判断 if (x &lt; 0) return false; int div = 1; // while (x / div &gt;= 10) div *= 10; while (x &gt; 0) { int left = x / div; int right = x % 10; if (left != right) return false; x = (x % div) / 10; div /= 100; } return true; 方法二：反转后半程数字 12345678910111213141516171819202122public boolean isPalindrome(int x) { // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) { return false; } int revertedNumber = 0; while (x &gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber / 10; } lico_回文子串个数统计给定字符串中连续子串是回文子串的子串的个数 lico_125 验证回文串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 Character.isLetterOrDigit(ch)可以获取是否是字母或数字 方法一：取出有效的从两头比对 方法二：直接在原字符串 s上使用双指针。在移动任意一个指针时，需要不断地向另一指针的方向移动，各自直到遇到一个字母或数字字符，或者两指针重合为止。","link":"/2022/07/11/Lico-type-huiwen/"}],"tags":[{"name":"1","slug":"1","link":"/tags/1/"},{"name":"2","slug":"2","link":"/tags/2/"},{"name":"回文","slug":"回文","link":"/tags/%E5%9B%9E%E6%96%87/"}],"categories":[{"name":"尝试","slug":"尝试","link":"/categories/%E5%B0%9D%E8%AF%95/"},{"name":"力扣(LeetCode)题型总结","slug":"力扣-LeetCode-题型总结","link":"/categories/%E5%8A%9B%E6%89%A3-LeetCode-%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"},{"name":"回文","slug":"力扣-LeetCode-题型总结/回文","link":"/categories/%E5%8A%9B%E6%89%A3-LeetCode-%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/%E5%9B%9E%E6%96%87/"}]}